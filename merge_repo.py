#!/usr/bin/env python3
"""
merge_repo.py â€” Merge Python source files from the 'src' subfolder into a single file.

Usage:
    python merge_repo.py [--root <repo_root>] [--out <merged_file>] [--folder src]

Defaults:
    --root   .
    --out    merged_repo.py
    --folder src

Behavior:
- Recursively collects *.py files under the given subfolder (relative to --root).
- Preserves per-file content verbatim (opened as UTF-8 with replacement for undecodable bytes).
- Inserts a clear header block before each file containing:
    * Original relative path within the repository
    * A best-effort import path (dot-separated) relative to the repo root
    * Hints extracted from env.sh if present (e.g., PYTHONPATH changes)

Notes:
- File order is stable and sorted (case-insensitive) by relative path.
- __init__.py files are included (they can document package structure).
- If duplicate module names occur, they are still included in distinct sections.
- The merged file starts with a table of contents to aid navigation.
"""

import os, sys, argparse

def read_env_sh(repo_root: str) -> str:
    for base, dirs, files in os.walk(repo_root):
        if 'env.sh' in files:
            p = os.path.join(base, 'env.sh')
            try:
                with open(p, 'r', encoding='utf-8', errors='replace') as f:
                    return f.read()
            except Exception:
                return ''
    return ''

def guess_import_path(rel_path: str) -> str:
    if rel_path.endswith('.py'):
        rel_path = rel_path[:-3]
    rel_path = rel_path.replace('\\', '/')
    parts = [p for p in rel_path.split('/') if p not in ('.', '')]
    return '.'.join(parts)

def collect_files(repo_root: str, folder: str):
    wanted = []
    base = os.path.join(repo_root, folder)
    if not os.path.isdir(base):
        return wanted
    for root, dirs, files in os.walk(base):
        dirs[:] = [d for d in dirs if d not in ('__pycache__', '.git', '.mypy_cache', '.pytest_cache', '.venv', 'venv')]
        for fn in files:
            if fn.endswith('.py'):
                full = os.path.join(root, fn)
                rel = os.path.relpath(full, repo_root)
                wanted.append(rel)
    wanted.sort(key=lambda s: s.lower())
    return wanted

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('--root', default='.', help='Repository root (default: .)')
    ap.add_argument('--out', default='merged_repo.py', help='Output merged file path')
    ap.add_argument('--folder', default='src', help='Subfolder to include (default: src)')
    args = ap.parse_args()

    repo_root = os.path.abspath(args.root)
    env_text = read_env_sh(repo_root)
    files = collect_files(repo_root, args.folder)

    header_lines = []
    header_lines.append('#' * 80)
    header_lines.append('# MERGED REPOSITORY FILE (auto-generated by merge_repo.py)')
    header_lines.append('#')
    header_lines.append('# Included subfolder: ' + args.folder)
    header_lines.append('# Repository root: ' + repo_root)
    header_lines.append('# Total files: ' + str(len(files)))
    header_lines.append('#')
    header_lines.append('# Table of Contents (relative path -> import path):')
    for rel in files:
        header_lines.append('# - {rel} -> {imp}'.format(rel=rel, imp=guess_import_path(rel)))
    header_lines.append('#')
    if env_text.strip():
        header_lines.append('# env.sh (excerpt, first 60 lines):')
        lines = env_text.splitlines()
        for line in lines[:60]:
            header_lines.append('# ' + line)
        if len(lines) > 60:
            header_lines.append('# ... (truncated)')
    else:
        header_lines.append('# No env.sh found or it was empty/unreadable.')
    header_lines.append('#' * 80)
    header_lines.append('')
    merged_header = '\n'.join(header_lines)

    os.makedirs(os.path.dirname(os.path.abspath(args.out)) or '.', exist_ok=True)
    with open(args.out, 'w', encoding='utf-8', errors='replace') as out:
        out.write(merged_header + '\n\n')
        for rel in files:
            imp = guess_import_path(rel)
            section_header = []
            section_header.append('\n' + '#' * 80)
            section_header.append('# BEGIN FILE: {rel}'.format(rel=rel))
            section_header.append('# Suggested import: {imp}'.format(imp=imp))
            if env_text.strip():
                section_header.append('# env.sh hints: the environment may export PYTHONPATH or other variables')
                section_header.append('# that affect how modules are imported. See the env.sh excerpt above.')
            section_header.append('# Additional context:')
            section_header.append('# - This block is a verbatim copy of the original file.')
            section_header.append('# - If this file defines __all__ or relies on package-relative imports, the order in')
            section_header.append('#   this merged file does not simulate runtime import side-effects; it is for reading.')
            section_header.append('# - Use the relative path to locate the original source in the repo.')
            section_header.append('#' * 80 + '\n')
            out.write('\n'.join(section_header))

            full = os.path.join(repo_root, rel)
            try:
                with open(full, 'r', encoding='utf-8', errors='replace') as f:
                    content = f.read()
            except Exception as e:
                content = '# ERROR reading file: {e}\n'.format(e=e)
            out.write(content)
            out.write('\n\n# END FILE: {rel}\n'.format(rel=rel))

if __name__ == '__main__':
    main()
